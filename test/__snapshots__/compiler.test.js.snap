// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`compiler on compile commonjs module type 1`] = `
"let mount = (domRoot, state) => {
  const _reactivePaths = [];
  return state => {
    Object.keys(_reactivePaths).forEach(key => {
      _reactivePaths[key].forEach(react => {
        if (react.type === 'attribute') {
          react.element.setAttribute(react.attribute, react.template(state));
        }
        if (react.type === 'text') {
          react.element.nodeValue = react.template(state);
        }
      });
    });
  };
};
module.exports = mount;"
`;

exports[`compiler on compile default module type generates es6 export 1`] = `
"let mount = (domRoot, state) => {
  const _reactivePaths = [];
  return state => {
    Object.keys(_reactivePaths).forEach(key => {
      _reactivePaths[key].forEach(react => {
        if (react.type === 'attribute') {
          react.element.setAttribute(react.attribute, react.template(state));
        }
        if (react.type === 'text') {
          react.element.nodeValue = react.template(state);
        }
      });
    });
  };
};
export default mount;"
`;

exports[`compiler on compile empty source 1`] = `
"let mount = (domRoot, state) => {
  const _reactivePaths = [];
  return state => {
    Object.keys(_reactivePaths).forEach(key => {
      _reactivePaths[key].forEach(react => {
        if (react.type === 'attribute') {
          react.element.setAttribute(react.attribute, react.template(state));
        }
        if (react.type === 'text') {
          react.element.nodeValue = react.template(state);
        }
      });
    });
  };
};
export default mount;"
`;

exports[`compiler on compile multiple tag nodes 1`] = `
"let mount = (domRoot, state) => {
  const _reactivePaths = [];
  console.log('COMPILED_TAG_NODE');
  console.log('COMPILED_TAG_NODE');
  return state => {
    Object.keys(_reactivePaths).forEach(key => {
      _reactivePaths[key].forEach(react => {
        if (react.type === 'attribute') {
          react.element.setAttribute(react.attribute, react.template(state));
        }
        if (react.type === 'text') {
          react.element.nodeValue = react.template(state);
        }
      });
    });
  };
};
export default mount;"
`;

exports[`compiler on compile nested nodes 1`] = `
"let mount = (domRoot, state) => {
  const _reactivePaths = [];
  console.log('COMPILED_TEXT_NODE');
  console.log('COMPILED_TAG_NODE');
  console.log('COMPILED_TEXT_NODE');
  return state => {
    Object.keys(_reactivePaths).forEach(key => {
      _reactivePaths[key].forEach(react => {
        if (react.type === 'attribute') {
          react.element.setAttribute(react.attribute, react.template(state));
        }
        if (react.type === 'text') {
          react.element.nodeValue = react.template(state);
        }
      });
    });
  };
};
export default mount;"
`;

exports[`compiler on compile simple closure export 1`] = `
"(() => {
  let mount = (domRoot, state) => {
    const _reactivePaths = [];
    return state => {
      Object.keys(_reactivePaths).forEach(key => {
        _reactivePaths[key].forEach(react => {
          if (react.type === 'attribute') {
            react.element.setAttribute(react.attribute, react.template(state));
          }
          if (react.type === 'text') {
            react.element.nodeValue = react.template(state);
          }
        });
      });
    };
  };
  return mount;
})();"
`;

exports[`compiler on compile single tag node 1`] = `
"let mount = (domRoot, state) => {
  const _reactivePaths = [];
  console.log('COMPILED_TAG_NODE');
  return state => {
    Object.keys(_reactivePaths).forEach(key => {
      _reactivePaths[key].forEach(react => {
        if (react.type === 'attribute') {
          react.element.setAttribute(react.attribute, react.template(state));
        }
        if (react.type === 'text') {
          react.element.nodeValue = react.template(state);
        }
      });
    });
  };
};
export default mount;"
`;

exports[`compiler on compile tag and text nodes 1`] = `
"let mount = (domRoot, state) => {
  const _reactivePaths = [];
  console.log('COMPILED_TEXT_NODE');
  console.log('COMPILED_TAG_NODE');
  console.log('COMPILED_TEXT_NODE');
  console.log('COMPILED_TAG_NODE');
  console.log('COMPILED_TEXT_NODE');
  return state => {
    Object.keys(_reactivePaths).forEach(key => {
      _reactivePaths[key].forEach(react => {
        if (react.type === 'attribute') {
          react.element.setAttribute(react.attribute, react.template(state));
        }
        if (react.type === 'text') {
          react.element.nodeValue = react.template(state);
        }
      });
    });
  };
};
export default mount;"
`;
